<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>테트리스 - 고스트 리플레이 대결</title>
    <style>
        body { background: #1a1a1a; color: white; font-family: 'Arial', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; overflow: hidden; }
        #main-layout { display: flex; gap: 30px; align-items: flex-start; }
        .canvas-label { text-align: center; margin-bottom: 10px; font-weight: bold; color: #aaa; font-size: 0.9em; }
        #canvas-container { position: relative; line-height: 0; }
        #pause-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 10; }
        #pause-overlay span { font-size: 1.2em; color: #ff3e3e; border: 2px solid #ff3e3e; padding: 5px 10px; }
        #next-container { display: flex; flex-direction: column; gap: 8px; background: #333; padding: 10px; border-radius: 8px; border: 2px solid #555; }
        .next-preview { width: 60px; height: 60px; background: #000; border: 1px solid #444; }
        canvas { border: 4px solid #fff; background-color: #000; }
        #replay-canvas { border-color: #555; opacity: 0.6; }
        .score-box { font-size: 1.5em; font-weight: bold; margin-bottom: 5px; color: #00d4ff; text-align: center; }
        button { padding: 10px 20px; font-size: 1em; cursor: pointer; background: #00d4ff; border: none; border-radius: 5px; font-weight: bold; }
        .info-panel { width: 150px; }
    </style>
</head>
<body>

    <div id="main-layout">
        <div>
            <div class="canvas-label">PAST BEST RECORD</div>
            <div class="score-box" id="best-score">Best: 0</div>
            <canvas id="replay-canvas" width="200" height="340"></canvas>
        </div>

        <div style="margin-top: 80px;">
            <div id="next-container">
                <div style="text-align:center; font-size:0.7em; color:#aaa;">NEXT</div>
                <canvas id="next0" class="next-preview" width="60" height="60"></canvas>
                <canvas id="next1" class="next-preview" width="60" height="60"></canvas>
                <canvas id="next2" class="next-preview" width="60" height="60"></canvas>
                <canvas id="next3" class="next-preview" width="60" height="60"></canvas>
            </div>
        </div>

        <div>
            <div class="canvas-label">CURRENT PLAY</div>
            <div class="score-box" id="current-score">0</div>
            <div id="canvas-container">
                <canvas id="tetris" width="240" height="400"></canvas>
                <div id="pause-overlay"><span>일시정지됨</span></div>
            </div>
        </div>

        <div class="info-panel" style="margin-top: 80px;">
            <button id="pause-btn">일시정지 (P)</button>
            <div style="font-size: 0.8em; color: #888; margin-top: 20px; line-height: 1.6;">
                P : 일시정지<br>
                ↑ : 회전<br>
                ← → : 이동<br>
                ↓ : 가속
            </div>
        </div>
    </div>

    <script>
        const PIECES = 'IJLOSTZ';
        const COLORS = { 'I': '#00f0f0', 'J': '#0000f0', 'L': '#f0a000', 'O': '#f0f000', 'S': '#00f000', 'T': '#a000f0', 'Z': '#f00000' };

        class TetrisEngine {
            constructor(canvas, isReplay = false) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.isReplay = isReplay;
                this.scale = isReplay ? 17 : 20;
                this.ctx.setTransform(1, 0, 0, 1, 0, 0); // 스케일 중첩 방지
                this.ctx.scale(this.scale, this.scale);
                
                this.arena = Array.from({length: 20}, () => Array(12).fill(0));
                this.player = { pos: {x: 0, y: 0}, matrix: null, score: 0, type: null };
                this.dropCounter = 0;
                this.dropInterval = 1000;
                this.pieceSequence = []; 
                this.inputLog = [];
                this.pieceIndex = 0;
                this.isGameOver = false;
            }

            createPiece(type) {
                if (type === 'I') return [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];
                if (type === 'J') return [[0,2,0],[0,2,0],[2,2,0]];
                if (type === 'L') return [[0,3,0],[0,3,0],[0,3,3]];
                if (type === 'O') return [[4,4],[4,4]];
                if (type === 'S') return [[0,5,5],[5,5,0],[0,0,0]];
                if (type === 'T') return [[0,6,0],[6,6,6],[0,0,0]];
                if (type === 'Z') return [[7,7,0],[0,7,7],[0,0,0]];
            }

            reset(sequence = null, inputs = []) {
                this.arena.forEach(row => row.fill(0));
                this.player.score = 0;
                this.pieceIndex = 0;
                this.isGameOver = false;
                this.dropCounter = 0;
                
                if (sequence) {
                    this.pieceSequence = [...sequence];
                    this.inputLog = [...inputs];
                } else {
                    this.pieceSequence = [];
                    this.inputLog = [];
                    for(let i=0; i<1000; i++) this.pieceSequence.push(PIECES[Math.random() * PIECES.length | 0]);
                }
                this.nextPiece();
            }

            nextPiece() {
                this.player.type = this.pieceSequence[this.pieceIndex++];
                this.player.matrix = this.createPiece(this.player.type);
                this.player.pos.y = 0;
                this.player.pos.x = (this.arena[0].length / 2 | 0) - (this.player.matrix[0].length / 2 | 0);
                
                if (this.collide()) {
                    this.isGameOver = true;
                    if (!this.isReplay) handleGameOver();
                }
            }

            collide() {
                const [m, o] = [this.player.matrix, this.player.pos];
                for (let y = 0; y < m.length; ++y) {
                    for (let x = 0; x < m[y].length; ++x) {
                        if (m[y][x] !== 0 && (this.arena[y + o.y] && this.arena[y + o.y][x + o.x]) !== 0) return true;
                    }
                }
                return false;
            }

            rotate(dir) {
                const pos = this.player.pos.x;
                let offset = 1;
                const m = this.player.matrix;
                for (let y = 0; y < m.length; ++y) {
                    for (let x = 0; x < y; ++x) [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
                }
                if (dir > 0) m.forEach(row => row.reverse()); else m.reverse();
                while (this.collide()) {
                    this.player.pos.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > m[0].length) { this.rotate(-dir); this.player.pos.x = pos; return; }
                }
            }

            drop() {
                if (this.isGameOver) return;
                this.player.pos.y++;
                if (this.collide()) {
                    this.player.pos.y--;
                    this.merge();
                    this.nextPiece();
                    this.sweep();
                }
                this.dropCounter = 0;
            }

            merge() {
                this.player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) this.arena[y + this.player.pos.y][x + this.player.pos.x] = value;
                    });
                });
            }

            sweep() {
                let rowCount = 1;
                outer: for (let y = this.arena.length - 1; y > 0; --y) {
                    for (let x = 0; x < this.arena[y].length; ++x) {
                        if (this.arena[y][x] === 0) continue outer;
                    }
                    const row = this.arena.splice(y, 1)[0].fill(0);
                    this.arena.unshift(row);
                    ++y;
                    this.player.score += rowCount * 10;
                    rowCount *= 2;
                }
            }

            draw() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawMatrix(this.arena, {x: 0, y: 0});
                if (!this.isGameOver) {
                    this.drawMatrix(this.player.matrix, this.player.pos, this.player.type);
                } else {
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.font = '1px Arial';
                    this.ctx.fillText("GAME OVER", 2, 10);
                }
            }

            drawMatrix(matrix, offset, type = null) {
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            this.ctx.fillStyle = type ? COLORS[type] : Object.values(COLORS)[value-1];
                            this.ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                        }
                    });
                });
            }
        }

        // 제어 변수
        const game = new TetrisEngine(document.getElementById('tetris'));
        const ghost = new TetrisEngine(document.getElementById('replay-canvas'), true);
        const nextCanvases = [0,1,2,3].map(i => document.getElementById('next'+i).getContext('2d'));
        let paused = false;
        let lastTime = 0;
        let gameTime = 0;

        function handleGameOver() {
            const bestData = JSON.parse(localStorage.getItem('tetris_best') || '{"score":0}');
            if (game.player.score > bestData.score) {
                const newRecord = {
                    score: game.player.score,
                    sequence: game.pieceSequence,
                    inputs: game.inputLog
                };
                localStorage.setItem('tetris_best', JSON.stringify(newRecord));
                alert("축하합니다! 최고 기록 경신!");
            } else {
                alert("게임 오버!");
            }
            initGhost(); // 리플레이 즉시 업데이트
            game.reset(); // 게임 재시작
            gameTime = 0;
        }

        function initGhost() {
            const data = localStorage.getItem('tetris_best');
            if (data) {
                const best = JSON.parse(data);
                document.getElementById('best-score').innerText = `Best: ${best.score}`;
                ghost.reset(best.sequence, best.inputs);
            }
        }

        function mainLoop(time = 0) {
            if (!paused) {
                const deltaTime = time - lastTime;
                lastTime = time;
                gameTime += deltaTime;

                game.dropCounter += deltaTime;
                if (game.dropCounter > game.dropInterval) game.drop();
                game.draw();

                // 리플레이 재생 로직
                if (!ghost.isGameOver && ghost.inputLog.length > 0) {
                    while(ghost.inputLog.length > 0 && ghost.inputLog[0].time <= gameTime) {
                        const input = ghost.inputLog.shift();
                        if(input.key === 'left') { ghost.player.pos.x--; if(ghost.collide()) ghost.player.pos.x++; }
                        if(input.key === 'right') { ghost.player.pos.x++; if(ghost.collide()) ghost.player.pos.x--; }
                        if(input.key === 'up') ghost.rotate(1);
                        if(input.key === 'down') ghost.drop();
                    }
                    ghost.dropCounter += deltaTime;
                    if (ghost.dropCounter > ghost.dropInterval) ghost.drop();
                    ghost.draw();
                } else if (ghost.isGameOver || ghost.inputLog.length === 0) {
                    // 리플레이가 끝나면 다시 처음부터 재생하거나 멈춤
                    if (ghost.isGameOver) {
                        setTimeout(() => initGhost(), 2000); // 2초 뒤 리플레이 재시작
                        ghost.isGameOver = false; 
                    }
                }
                
                document.getElementById('current-score').innerText = game.player.score;
                updateNextUI();
            }
            requestAnimationFrame(mainLoop);
        }

        function updateNextUI() {
            nextCanvases.forEach((ctx, i) => {
                ctx.setTransform(15, 0, 0, 15, 0, 0);
                ctx.fillStyle = '#000';
                ctx.fillRect(0,0,4,4);
                const type = game.pieceSequence[game.pieceIndex + i];
                if(type) {
                    const m = game.createPiece(type);
                    m.forEach((row, y) => row.forEach((v, x) => {
                        if(v) { ctx.fillStyle = COLORS[type]; ctx.fillRect(x,y,1,1); }
                    }));
                }
            });
        }

        document.addEventListener('keydown', e => {
            if (e.keyCode === 80) {
                paused = !paused;
                document.getElementById('pause-overlay').style.display = paused ? 'flex' : 'none';
                if(!paused) lastTime = performance.now();
                return;
            }
            if (paused || game.isGameOver) return;

            if (e.keyCode === 37) { // Left
                game.player.pos.x--;
                if(game.collide()) game.player.pos.x++;
                else game.inputLog.push({time: gameTime, key: 'left'});
            } else if (e.keyCode === 39) { // Right
                game.player.pos.x++;
                if(game.collide()) game.player.pos.x--;
                else game.inputLog.push({time: gameTime, key: 'right'});
            } else if (e.keyCode === 38) { // Up
                game.rotate(1);
                game.inputLog.push({time: gameTime, key: 'up'});
            } else if (e.keyCode === 40) { // Down
                game.drop();
                game.inputLog.push({time: gameTime, key: 'down'});
            }
            game.draw();
        });

        document.getElementById('pause-btn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause-overlay').style.display = paused ? 'flex' : 'none';
            if(!paused) lastTime = performance.now();
        });

        // 초기 시작
        initGhost();
        game.reset();
        mainLoop();
    </script>
</body>
</html>
